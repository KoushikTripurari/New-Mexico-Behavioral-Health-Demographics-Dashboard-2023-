<script>
const $ = s => document.querySelector(s);

// Pretty-print the actual error message
function showError(msg){
  const e = document.getElementById("msgErr");
  e.textContent = msg;
  e.style.display = "block";
}
function clearError(){
  const e = document.getElementById("msgErr");
  e.textContent = "";
  e.style.display = "none";
}

// Robust Excel/CSV loader
async function robustReadWorkbook(file){
  // Guardrails
  const MAX_BYTES = 40 * 1024 * 1024; // 40 MB
  if (file.size > MAX_BYTES) throw new Error(`File is too large (${(file.size/1024/1024).toFixed(1)} MB). Try a smaller sheet or CSV under ${(MAX_BYTES/1024/1024)} MB.`);

  const ext = (file.name.split(".").pop() || "").toLowerCase();
  if (!["xlsx","xls","csv"].includes(ext)){
    throw new Error(`Unsupported file type ".${ext}". Please use .xlsx, .xls, or .csv.`);
  }

  // Helper to try different read modes
  const tryRead = (data, opts) => {
    try {
      return XLSX.read(data, opts); // success → return workbook
    } catch (err) {
      return err; // return error to try next mode
    }
  };

  // 1) ArrayBuffer (modern)
  const buf = await file.arrayBuffer();
  let wb = tryRead(buf, { type: "array", cellDates: true, raw: false });
  if (wb && wb.SheetNames) return wb;     // success

  // 2) Uint8Array (some older BIFF8 .xls need this)
  const u8 = new Uint8Array(buf);
  wb = tryRead(u8, { type: "array", cellDates: true, raw: false });
  if (wb && wb.SheetNames) return wb;     // success

  // 3) BinaryString fallback (widely compatible)
  const bin = await new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = () => reject(fr.error || new Error("Binary read failed"));
    fr.readAsBinaryString(file);
  });
  wb = tryRead(bin, { type: "binary", cellDates: true, raw: false });
  if (wb && wb.SheetNames) return wb;

  // If all modes failed, throw the last error’s message
  const errMsg = (wb && wb.message) ? wb.message : "Unknown parse failure";
  throw new Error(`Workbook parse failed (${ext}). Details: ${errMsg}`);
}

// ===== Replace your old #file change handler with this one =====
document.getElementById("file").addEventListener("change", async (ev) => {
  clearError();
  const f = ev.target.files?.[0];
  if (!f) return;

  try {
    if (!(window.XLSX && window.Chart)) {
      throw new Error("Libraries not loaded. You must be online or self-host xlsx.full.min.js and chart.umd.min.js.");
    }

    const wb = await robustReadWorkbook(f);
    const first = wb.Sheets[wb.SheetNames[0]];
    if (!first) throw new Error("No sheets found in workbook (first sheet missing).");

    // Prefer object rows for tidy; array rows for two-block fallback
    const json = XLSX.utils.sheet_to_json(first, { defval: "" });
    let parsed = tryParseTidy(json);      // from previous code
    if (!parsed) parsed = tryParseTwoBlock(first); // from previous code

    if (!parsed || !parsed.length) {
      throw new Error(
        "Parsed the file but couldn’t find the expected columns.\n" +
        "Accepted formats:\n" +
        "1) Tidy: Service | Statewide | BR1 (header row required)\n" +
        "2) Two-block: (Statewide) Service/Count + (BR1) Service/Count on the same rows, with a header row that contains the words 'Statewide' and 'BR1'.\n" +
        "Make sure your data is on the FIRST sheet (move it there if needed) and cells aren’t cross-row merged."
      );
    }

    // success → store and render (these functions already exist in your file)
    rows = parsed.filter(r => r.Service && (!isNaN(r.Statewide) || !isNaN(r.BR1)));
    if (!rows.length) throw new Error("All rows had empty or non-numeric counts after cleaning.");
    const ok = document.getElementById("msgOk");
    ok.textContent = `Loaded ${rows.length} services from "${f.name}".`;
    ok.style.display = "block";
    setTimeout(()=>ok.style.display="none", 2500);
    render();
  } catch (err) {
    console.error(err);
    showError(err?.message || String(err));
  }
});
</script>
